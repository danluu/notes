* questions
  Think about self-triggering always block section
  What's a pulse stretcher?
  Remember what a schmidtt trigger is?

* Synthesis gotchas
** sensitivity list / latching
   always blocks without posedge or negedge turn into latches, regardless of sensitivity list
   i.e., having an incomplete sensitivity list will cause incorrect pre-synthesis simulation
** ordering inside block
   using a temporary variable before it's assigned will not synthesize correctly

   always @ (a or b or c or d) begin
     o = a & b | temp;
     temp = c & d;
   end

   will synthesize to the same thing, even if we swap the two lines
   i.e., we'll get an and-or gate post-synthesis either way
** functions
   functions always produce combinational logic.
   Creating latching behavior will cause a problem
** case statements
   A case statement is normally equivalent to a series of "if else" statements

   (synopsis)
   //synopsis full_case

   This says that case statement is fully defined; unused cases should be don't cares.
   In addition to the obvious effect,
   this can cause logic to get optimized away in synthesis
   
   Note that we can make a statement full, in simulation, by adding a default
   Could have the default go to X

   Otherwise, we'll latch the last input if we fall into an empty case

   //synopsis parallel_case
   
   This causes all cases to be tested in parallel, even if we have overlapping cases,
   where you'd normally get a priority encoder

   But, if we want that, we can also do it 'manually'
   Say we have a case statement with the following:

   1??
   ?1?
   ??1

   Instead of using parallel_case, which will cause a simulation mismatch, we can do this:
  
   1??
   01?
   001

** casex vs. casez
   casex matches Xs as don't cares (in both the case expression and the item)
   Post-sythesis, the x will propogate and cause the gate level model to X out

** translate_on / translate_off
   Bad idea, most of the time, except for debug logic

   Interesting exception is a D-flip flop
   If we code it in the obvious style (negedge resetb, negedge setb), asserting both and then removing one fails to simulate correctly even though synthesis works
** #delays
   Won't synthesize, obv.
* blocking vs. non-blocking assignments
  General guideline is non-blocking for sequential and blocking for combinational. But why?
  Note that if we have combinational and sequential logic in the same block, we should use non-blocking assignments
  Should never mix blocking and non-blocking in the same block

  Note that seperate blocks can be scheduled in any order
** blocking assignments
   Can think of it as a one step process
   evaluate RHS, update LHS. Blocks other assignments *in the same block* until it's finished
   Can have race conditions if used in multiple blocks (say we have two different posedge clk blocks, like we would for two chunks of sequential logic)
** non-blocking assignments
   Can think of it as a two step process
   1. Evaluate RHS of all non-blocking statements
   2. Update LHS of all non-blocking statements

   Note: if we re-assign a variable multiple times within an always block, the last one wins
   If we assign from seperate blocks, that's a race condition
** verilog "stratified event queue"
*** Active events
    Blocking assignments, non-blocking RHS, continuous assigments, $display, primitives
*** Inactive events
    #0 blocking assignments. Don't use this!
*** NBA
    Update non-blocking things. This can re-trigger more active events
*** Postponed (monitor events queue)
    $monitor, $strobe
** self-triggering always blocks
   Can't be done with blocking assignments. We could try to use a #delay, but, say we do this:
   always @(clk) #10 clk = ~clk;
   
   Blocking assignment must complete before edge-trigger event can be scheduled.
   When trigger event is scheduled, assignment has completed,
   so we don't have a trigger from within the block to trigger transition
* resets
  General guideline: every FF should have a reset, except perhaps follower FFs in high speed logic (shift register)
  Cummings prefer asyc resets
** synchronus resets
   Pros: don't have to worry about spurious reset from glitches. Also, more noise tolerant
   Smaller logic, better compatability with some cycle based simulators
   Cons: If reset tree has high fanout, and reset is late arriving, have to schedule time for reset
   May need to use a pulse stretcher to get a wide enough reset pulse
   Synchronus reset may put logic on the datapath (timing issue)

   May be annoying with some design styles. Reset doesn't happen until we have a clock edge, but, if we have, e.g., an internal tri-state bus,
   we want to reset on power up to avoid contention
** asynchronus resets
   Must handle reset removal correctly! If we release reset near a clock edge, we may get metastability
   This means we need a reset synchronizer.

   Design is simple. If we have two DFFs in a row, with our external reset going to those resets, that will synchronize the reset.
   First DFF gets reset as normal. Second is to remove any metastability

   If we have multiple clock domains, we need a synchronizer for each clock domain
   Depending on the design, we may need a certain sequence of reset removal

   We can do this by having the output of one synchronier (reset) be the input of another synchornizer (normally, the external reset)

   To avoid reset glitches, we may want a schmidtt trigger on the reset input.
   Also, to filter glitches, we can use a delay line and an or gate

   TODO: go back and read section on precise multi-ASIC resets
