* questions
  Think about self-triggering always block section

* Synthesis gotchas
** sensitivity list / latching
   always blocks without posedge or negedge turn into latches, regardless of sensitivity list
   i.e., having an incomplete sensitivity list will cause incorrect pre-synthesis simulation
** ordering inside block
   using a temporary variable before it's assigned will not synthesize correctly

   always @ (a or b or c or d) begin
     o = a & b | temp;
     temp = c & d;
   end

   will synthesize to the same thing, even if we swap the two lines
   i.e., we'll get an and-or gate post-synthesis either way
** functions
   functions always produce combinational logic.
   Creating latching behavior will cause a problem
** case statements
   A case statement is normally equivalent to a series of "if else" statements

   (synopsis)
   //synopsis full_case

   This says that case statement is fully defined; unused cases should be don't cares.
   In addition to the obvious effect,
   this can cause logic to get optimized away in synthesis
   
   Note that we can make a statement full, in simulation, by adding a default
   Could have the default go to X

   Otherwise, we'll latch the last input if we fall into an empty case

   //synopsis parallel_case
   
   This causes all cases to be tested in parallel, even if we have overlapping cases,
   where you'd normally get a priority encoder

   But, if we want that, we can also do it 'manually'
   Say we have a case statement with the following:

   1??
   ?1?
   ??1

   Instead of using parallel_case, which will cause a simulation mismatch, we can do this:
  
   1??
   01?
   001

** casex vs. casez
   casex matches Xs as don't cares (in both the case expression and the item)
   Post-sythesis, the x will propogate and cause the gate level model to X out

** translate_on / translate_off
   Bad idea, most of the time, except for debug logic

   Interesting exception is a D-flip flop
   If we code it in the obvious style (negedge resetb, negedge setb), asserting both and then removing one fails to simulate correctly even though synthesis works
** #delays
   Won't synthesize, obv.
* blocking vs. non-blocking assignments
  General guideline is non-blocking for sequential and blocking for combinational. But why?
  Note that if we have combinational and sequential logic in the same block, we should use non-blocking assignments
  Should never mix blocking and non-blocking in the same block

  Note that seperate blocks can be scheduled in any order
** blocking assignments
   Can think of it as a one step process
   evaluate RHS, update LHS. Blocks other assignments *in the same block* until it's finished
   Can have race conditions if used in multiple blocks (say we have two different posedge clk blocks, like we would for two chunks of sequential logic)
** non-blocking assignments
   Can think of it as a two step process
   1. Evaluate RHS of all non-blocking statements
   2. Update LHS of all non-blocking statements

   Note: if we re-assign a variable multiple times within an always block, the last one wins
   If we assign from seperate blocks, that's a race condition
** verilog "stratified event queue"
*** Active events
    Blocking assignments, non-blocking RHS, continuous assigments, $display, primitives
*** Inactive events
    #0 blocking assignments. Don't use this!
*** NBA
    Update non-blocking things. This can re-trigger more active events
*** Postponed (monitor events queue)
    $monitor, $strobe
** self-triggering always blocks
   Can't be done with blocking assignments. We could try to use a #delay, but, say we do this:
   always @(clk) #10 clk = ~clk;
   
   Blocking assignment must complete before edge-trigger event can be scheduled.
   When trigger event is scheduled, assignment has completed,
   so we don't have a trigger from within the block to trigger transition
